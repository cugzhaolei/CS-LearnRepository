# Socket

## TCP/IP通信

### 三握四挥



## 滑动窗口

### 滑动窗口算法（Sliding window algorithm)

> Sliding window algorithm is used to perform required operation on specific window size of given large buffer or array.
>
> 滑动窗口算法是在给定特定窗口大小的数组或字符串上执行要求的操作。

> This technique shows how a nested for loop in few problems can be converted to single for loop and hence reducing the time complexity.
>
> 该技术可以将一部分问题中的嵌套循环转变为一个单循环，因此它可以减少时间复杂度。

简而言之，滑动窗口算法在一个特定大小的字符串或数组上进行操作，而不在整个字符串和数组上操作，这样就降低了问题的复杂度，从而也达到降低了循环的嵌套深度。**其实这里就可以看出来滑动窗口主要应用在数组和字符串上。**

如下图所示，设定滑动窗口（window）大小为 3，当滑动窗口每次划过数组时，计算当前滑动窗口中元素的和，得到结果 res。

![滑动窗口算法基本](https://img-blog.csdnimg.cn/20190305164439172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xtMjc4ODU4NDQ1,size_16,color_FFFFFF,t_70)
可以用来解决一些查找满足一定条件的连续区间的性质（长度等）的问题。由于区间连续，因此当区间发生变化时，可以通过旧有的计算结果对搜索空间进行剪枝，这样便减少了重复计算，降低了时间复杂度。往往类似于“ 请找到满足 xx 的最 x 的区间（子串、子数组）的 xx ”这类问题都可以使用该方法进行解决。

需要注意的是，滑动窗口算法更多的是一种思想，而非某种数据结构的使用。 

# 滑动窗口法的大体框架

在介绍滑动窗口的框架时候，大家先从字面理解下：

- **滑动：**说明这个窗口是移动的，也就是移动是按照一定方向来的。
- **窗口：**窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。

为了便于理解，这里采用的是字符串来讲解。但是对于数组其实也是一样的。滑动窗口算法的思路是这样：

1. 我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。
2. 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。
3. 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。
4. 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。

这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。

下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。

初始状态：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019101621574345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70)

增加 right，直到窗口 [left, right] 包含了 T 中所有字符：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20191016215752186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70)

现在开始增加 left，缩小窗口 [left, right]。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191016215807735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70)

直到窗口中的字符串不再符合要求，left 不再继续移动。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20191016215824468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70)

之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。

如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。

上述过程对于非固定大小的滑动窗口，可以简单地写出如下伪码框架：

```c
string s, t;
    // 在 s 中寻找 t 的「最小覆盖子串」
    int left = 0, right = 0;
    string res = s;
    
    while(right < s.size()) {
        window.add(s[right]);
        right++;
        // 如果符合要求，说明窗口构造完成，移动 left 缩小窗口
        while (window 符合要求) {
            // 如果这个窗口的子串更短，则更新 res
            res = minLen(res, window);
            window.remove(s[left]);
            left++;
        }
    }
    return res;
```

但是，对于固定窗口大小，可以总结如下：

```c
       // 固定窗口大小为 k
        string s;
        // 在 s 中寻找窗口大小为 k 时的所包含最大元音字母个数
        int  right = 0;
	while(right < s.size()) {
        window.add(s[right]);
        right++;
        // 如果符合要求，说明窗口构造完成，
        if (right>=k) {
            // 这是已经是一个窗口了，根据条件做一些事情
           // ... 可以计算窗口最大值等 
            // 最后不要忘记把 right -k 位置元素从窗口里面移除
        }
    }
    return res;
```

可以发现此时不需要依赖 left 指针了。因为窗口固定所以其实就没必要使用left，right 双指针来控制窗口的大小。

其次是对于窗口是固定的，可以轻易获取到 left 的位置，此处 left = right-k;



### TCP滑动窗口

![img](https://i.loli.net/2021/03/05/g8XdxqjWYI13AoB.png)

`滑动窗口协议（Sliding Window Protocol），属于TCP协议的一种应用，用于网络数据传输时的流量控制，以避免拥塞的发生。`该协议允许发送方在停止并等待确认前发送多个数据分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输，提高网络吞吐量。

TCP通过滑动窗口的概念来进行流量控制。设想在发送端发送数据的速度很快而接收端接收速度却很慢的情况下，为了保证数据不丢失，显然需要进行流量控制， 协调好通信双方的工作节奏。所谓滑动窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓 冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供`65535`个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。 

滑动窗口本质上是描述接受方的TCP数据报缓冲区大小的数据，发送方根据这个数据来计算自己最多能发送多长的数据。如果发送方收到接受方的窗口大小为0的TCP数据报，那么发送方将停止发送数据，等到接受方发送窗口大小不为0的数据报的到来。 

​    `窗口合拢`：当窗口从左边向右边靠近的时候，这种现象发生在数据被发送和确认的时候。  
​    `窗口张开`：当窗口的右边沿向右边移动的时候，这种现象发生在接受端处理了数据以后。  
​    `窗口收缩`：当窗口的右边沿向左边移动的时候，这种现象不常发生。  
​    TCP就是用这个窗口，慢慢的从数据的左边移动到右边，把处于窗口范围内的数据发送出去（但不用发送所有，只是处于窗口内的数据可以发送。）。这就是窗口的意义。窗口的大小是可以通过socket来制定的，4096并不是最理想的窗口大小，而`16384`则可以使吞吐量大大的增加。

A————C————B

如上图，A与B之间建立TCP连接，滑动窗口实现有两个作用： 

由于对称性，只考虑A端发送窗口和B端接收窗口，有如下两个作用  

1、B端来不及处理接收数据（控制不同速率主机间的同步），这时，A通过B端通知的接收窗口而减缓数据的发送。  
2、B端来得及处理接收数据，但是在A与B之间某处如C，使得AB之间的整体带宽性能较差，此时，A端根据`拥塞处理策略（慢启动，加倍递减和缓慢增加）`来更新窗口，以决定数据的发送。  

与固定大小的滑窗协议相比，TCP采用可变大小的滑窗协议是为了取得更好的性能。  

**TCP是一个广域网协议，而广域网环境下的路由器和主机，各自有着不同的性能和处理能力，在这种情况下，采用固定窗口大小的滑窗协议会引起性能上的损失。TCP规定窗口的大小是由接收方通告的，通过采取慢启动和拥塞避免算法等机制来使带宽和性能取得最佳。**

1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；

2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。

   1.TCP协议的两端分别为发送者A和接收者B，由于是`全双工协议`，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；

   2.发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；

   3.发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据

   4. 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将 新的数据包含到窗口中准备发送；

TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’：字节31-50为发送窗口。

![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103216771-1670044829.png)

根据B给出窗口值，A构造自己的窗口

A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组：

![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103229927-547362366.png)

A发了11个字节数据

只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：

![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103247631-88673213.png)

A收到新的确认号，窗口向前滑动

![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103307521-1996996021.png)

发送窗口内的序号都属于已发送但未被确认

> 所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送：

![img](https://images2017.cnblogs.com/blog/1232796/201710/1232796-20171016103322162-1872321900.png)

> 这里面涉及到一种情况，如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。为了处理这种问题，`TCP引入了持续计时器（Persistence timer）`，当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。

#### **传递效率**
​	一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是:

​	a.尽可能一次多发送几个字节;

​	b:或者窗口空余较多的时候通知发送方一次发送多个字节。

​	对于前者a我们广泛使用`Nagle算法`，即：
​		*1. 若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；
​		*2. 当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；
​		*3. 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；
​	对于后者b我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。

#### **拥塞控制**
​       网络中的`链路容量`和交换结点中的缓存和处理机都有着工作的极限，**当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。**常用的方法就是：

> - 慢开始、拥塞控制
>
> - 快重传、快恢复
>
>    一切的基础还是`慢开始`，这种方法的思路是这样的：
>   -1. 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口；
>   -2. 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文；
>   -3. 当收到第一个字节的数据的确认后，就发送2个字节的报文；
>   -4. 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级；
>   -5. 最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定：(cwnd = crowde window ssthresh = slow start threshold)
>        *a. cwnd < ssthresh， 继续使用慢开始算法；
>        *b. cwnd > ssthresh，停止使用慢开始算法，改用拥塞避免算法；
>        *c. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；
>   -6. 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长；
>   -7. 当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）；

![img](https://i.loli.net/2021/03/05/n1uREYFtrJpOBl9.png)

**上述方法的目的是在拥塞发生时循序减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕**。`慢开始和拥塞控制`算法常常作为一个整体使用，而`快重传和快恢复`则是为了减少因为拥塞导致的数据包丢失带来的重传时间，从而避免传递无用的数据到网络。

快重传的机制是：
-1. 接收方建立这样的机制，如果一个包丢失，则对后续的包继续发送针对该包的重传请求；
-2. 一旦发送方接收到三个一样的确认，就知道该包之后出现了错误，立刻重传该包；
-3. 此时发送方开始执行“快恢复”算法：
    *1. 慢开始门限减半；
    *2. cwnd设为慢开始门限减半后的数值；
    *3. 执行拥塞避免算法（高起点，线性增长）；

![img](https://i.loli.net/2021/03/05/n1uREYFtrJpOBl9.png)



实际上，对于窗口的构造是很重要的。具体可以看下面的实例。







# 算法实例

## [1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)

给你两个长度相同的字符串，s 和 t。

将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

**示例 1：**

```
输入：s = "abcd", t = "bcdf", cost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。
```

**示例 2：**

```
输入：s = "abcd", t = "cdef", cost = 3
输出：1
解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。
```

**示例 3：**

```
输入：s = "abcd", t = "acde", cost = 0
输出：1
解释：你无法作出任何改动，所以最大长度为 1。 
```

### 代码



由于 `diff` 的的每个元素都是非负的，因此可以用滑动窗口的方法得到符合要求的最长子数组的长度。

滑动窗口的思想是，维护两个指针 `start` 和 `end` 表示数组 `diff` 的子数组的开始下标和结束下标，满足子数组的元素和不超过 `maxCost`，子数组的长度是 `end−start+1`。初始时，`start` 和 `end` 的值都是 `0`。

另外还要维护子数组的元素和 `sum`，初始值为 `0`。在移动两个指针的过程中，更新 `sum` 的值，判断子数组的元素和是否大于 `maxCost`，并决定应该如何移动指针。

为了得到符合要求的最长子数组的长度，应遵循以下两点原则：

* 当 `start` 的值固定时，`end` 的值应尽可能大；

* 当 `end` 的值固定时，`start` 的值应尽可能小。

基于上述原则，滑动窗口的做法如下：

* 1. 将 `diff[end]` 的值加到 `sum`；

* 2. 如果  `sum≤maxCost`，则子数组的元素和不超过 `maxCost`，使用当前子数组的长度 `end−start+1` 更新最大子数组的长度；

* 3. 如果 `sum>maxCost`，则子数组的元素和大于 `maxCost`，需要向右移动指针 `start` 并同时更新 `sum` 的值，直到  `sum≤maxCost`，此时子数组的元素和不超过 `maxCost`，使用子数组的长度`end−start+1` 更新最大子数组的长度；

* 4. 将指针 end 右移一位，重复上述步骤，直到 end 超出数组下标范围。

遍历结束之后，即可得到符合要求的最长子数组的长度，即字符串可以转化的最大长度。

```js
var equalSubstring = function(s,t,maxCost){
    const n = s.length;
    const diff = new Array(n).fill(0);
    for(let i=0;i<n;i++){
        diff[i] = Math.abs(s[i].charCodeAt()-t[i].charCodeAt());
    }
    let maxLength = 0;
    let start = 0, end = 0;
    let sum = 0;
    while(end<n){
        sum+=diff[end];  // 向右移动 加入差值
        while(sum>maxCost){ //超出最大的允许值
            执行上面的3
	    sum -=diff[start]; // start往前移动 减去前面的差值
            start++; // 向前移动
        }
        maxLength = Math.max(maxLength,end-start+1);
        end++;
    }
    return maxLength;
};
```

**复杂度分析**

* 时间复杂度：`O(n)`，其中 n 是字符串的长度。
  计算数组 `diff` 的时间复杂度是 `O(n)`。
  遍历数组的过程中，两个指针的移动次数都不会超过 `n` 次。
  因此总时间复杂度是 `O(n)`。

* 空间复杂度：`O(n)`，其中 `n` 是字符串的长度。需要创建长度为 `n` 的数组 `diff`。





### 参考

[1.滑动窗口算法基本原理与实践](https://www.cnblogs.com/huansky/p/13488234.html)(https://www.cnblogs.com/huansky/p/13488234.html)

[2.leetcode](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/jin-ke-neng-shi-zi-fu-chuan-xiang-deng-b-higz/)

[3.TCP滑动窗口](https://www.cnblogs.com/alifpga/p/7675850.html)

[4.TCP协议的滑动窗口具体是怎样控制流量的？](https://www.zhihu.com/question/32255109)

[5.TCP 的那些事儿（上）](https://coolshell.cn/articles/11564.html#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6)

## 累计积分

### 参考

[TCP超时重传和累积确认怎么理解？](https://www.zhihu.com/question/414447339)

## 分组缓存



## 流量控制



### [RFC](https://baike.baidu.com/item/RFC/1840?fr=aladdin)

Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和[互联网](https://baike.baidu.com/item/互联网/199186)社区的[软件](https://baike.baidu.com/item/软件/12053)文件。RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多在标准内的论题，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。



