### 2021-3

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

**难度**`中等`

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

 

> 示例 1：
>
> 输入：s = "3+2*2"
> 输出：7
> 示例 2：
>
> 输入：s = " 3/2 "
> 输出：1
> 示例 3：
>
> 输入：s = " 3+5 / 2 "
> 输出：5


提示：

- 1 <= s.length <= 3 * 105
- s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
- s 表示一个 有效表达式
- 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
- 题目数据保证答案是一个 32-bit 整数

##### [题解](https://leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/)

方法一：栈
思路

由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。

基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。

具体来说，遍历字符串 `s`，并用变量`preSign` 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 `preSign` 来决定计算方式：

* 加号：将数字压入栈；
* 减号：将数字的相反数压入栈；
* 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。
  代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 `preSign` 为当前遍历的字符。

遍历完字符串 ss 后，将栈中元素累加，即为该字符串表达式的值

```js
var calculate = function(s) {
    s = s.trim();
    const stack = new Array();
    let preSign = '+';
    let num = 0;
    const n = s.length;
    for (let i = 0; i < n; ++i) {
        if (!isNaN(Number(s[i])) && s[i] !== ' ') { // 是数字或者是空格时
            num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt(); // 全局num 1 12 123
        }
        if (isNaN(Number(s[i])) || i === n - 1) { //特殊符号 或者是最后一个
            switch (preSign) {
                case '+':
                    stack.push(num);
                    break;
                case '-':
                    stack.push(-num);
                    break;
                case '*':
                    stack.push(stack.pop() * num);
                    break;
                default:
                    stack.push(stack.pop() / num | 0);
            }   
            preSign = s[i];
            num = 0;
        }
    }
    let ans = 0;
    while (stack.length) {
        ans += stack.pop();
    }
    return ans;
};
```

##### 复杂度分析

时间复杂度：`O(n)`，其中 `n` 为字符串 `s`的长度。需要遍历字符串 `s` 一次，计算表达式的值。

空间复杂度：`O(n)`，其中 `n`为字符串 `s` 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 `n`。

 ##### 参考链接

https://leetcode-cn.com/problems/basic-calculator-ii/

https://leetcode-cn.com/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/



#### [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

**难度** `中等` `栈`



序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

```bash
       _9_
      /   \
     3     2
   / \    / \
  4   1  #  6
 / \  / \   / \
# # # #  #  #
```


例如，上面的二叉树可以被序列化为字符串` "9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如` "1,,3"` 。

> 示例 1:
>
> 输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
> 输出: true`
> 示例 2:
>
> 输入: "1,#"
> 输出: false
> 示例 3:
>
> 输入: "9,#,#,1"
> 输出: false



##### [题解一](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/)

我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。

二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：

* 如果遇到了空节点，则要消耗一个槽位；

* 如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。

此外，还需要将根节点作为特殊情况处理。

![fig1](https://i.loli.net/2021/03/13/PivywLpIotOg6MH.png)

我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 1；当遇到非空节点时，**将栈顶元素减** 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0，就立刻将栈顶弹出。

遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。

```js
/**
 * @param {string} preorder
 * @return {boolean}
 */
var isValidSerialization = function(preorder) {
    const n = preorder.length;
    let i = 0;
    const stack = [1];
    while (i < n) {
        if (!stack.length) {
            return false;
        }
        if (preorder[i] === ',') {
            ++i;
        } else if (preorder[i] === '#') {
            stack[stack.length - 1]--;
            if (stack[stack.length - 1] === 0) {
                stack.pop();
            } 
            ++i;
        } else {
            // 读一个数字
            while (i < n && preorder[i] !== ',') {
                ++i;
            }
            stack[stack.length - 1]--;
            if (stack[stack.length - 1] === 0) {
                stack.pop();
            }
            stack.push(2);
        }
    }
    return stack.length === 0;
};

// 将栈顶的操作每次都在取数的时候操作

```



##### 复杂度分析

时间复杂度：`O(n)`，其中 `n` 为字符串的长度。我们每个字符只遍历一次，同时每个字符对应的操作都是常数时间的。

空间复杂度：`O(n)`。此为栈所需要使用的空间

##### [解法二](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/pai-an-jiao-jue-de-liang-chong-jie-fa-zh-66nt/)

X # #的数据合成

如输入：` "9,3,4,#,#,1,#,#,2,#,6,#,#" `，当遇到 `x,#,#` 的时候，就把它变为` #`。

模拟一遍过程：

> [9,3,4,#,#] => [9,3,#]，继续
> [9,3,#,1,#,#] => [9,3,#,#] => [9,#] ，继续
> [9,#2,#,6,#,#] => [9,#,2,#,#] => [9,#,#] => [#]，结束



```js
/**
 * @param {string} preorder
 * @return {boolean}
 */
var isValidSerialization = function(preorder) {
    let stack= [];
    for(let s of preorder.split(',')){
        stack.unshift(s);
        while(stack.length>=3&&stack[0] == '#'&&stack[1] == '#'&&stack[2] != '#'){
            stack.shift();
            stack.shift();
            stack.shift();
            stack.unshift('#');
        }
    }
    return stack.length == 1&&stack.shift() == '#';
};
```

- 时间复杂度：`O(N)`
- 空间复杂度：`O(N)`

###### 计算入度出度

背景知识：

* 入度：有多少个节点指向它；
* 出度：它指向多少个节点。
  我们知道在树（甚至图）中，所有节点的入度之和等于出度之和。可以根据这个特点判断输入序列是否为有效的！

在一棵二叉树中：

* 每个空节点（ "#" ）会提供 0 个出度和 1 个入度。
* ..每个非空节点会提供 2 个出度和 1 个入度（根节点的入度是 0）。

我们只要把字符串遍历一次，每个节点都累加 `diff = 出度 - 入度` 。在遍历到任何一个节点的时候，要求`diff >= 0`，原因是还没遍历到该节点的子节点，所以此时的出度应该大于等于入度。当所有节点遍历完成之后，整棵树的` diff == 0` 。

这里解释一下为什么下面的代码中 diff 的初始化为 1。因为，我们加入一个非空节点时，都会对 diff 先减去 1（入度），再加上 2（出度）。但是由于根节点没有父节点，所以其入度为 0，出度为 2。因此 diff 初始化为 1，是为了在加入根节点的时候，diff 先减去 1（入度），再加上 2（出度），此时 diff 正好应该是2.



```js
var isValidSerialization = function(preorder) {
    const nodes = preorder.split(',');
    let diff = 1;
    for(const node of nodes){
        diff -=1;
        if(diff<0){
            return false;
        }
        if(node!='#'){
            diff +=2;
        }
    }
    return diff == 0;
}
```

- 时间复杂度：`O(N)`
- 空间复杂度：`O(1)`

##### 参考链接

1. https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/


#### [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)

不使用任何内建的哈希表库设计一个哈希集合（HashSet）。

实现 MyHashSet 类：

* void add(key) 向哈希集合中插入值 key 。
* bool contains(key) 返回哈希集合中是否存在这个值 key 。
* void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。

示例：

> 输入：
> ["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
> [[], [1], [2], [1], [3], [2], [2], [2], [2]]
> 输出：
> [null, null, null, true, false, null, true, null, false]
>
> 解释：
> MyHashSet myHashSet = new MyHashSet();
> myHashSet.add(1);      // set = [1]
> myHashSet.add(2);      // set = [1, 2]
> myHashSet.contains(1); // 返回 True
> myHashSet.contains(3); // 返回 False ，（未找到）
> myHashSet.add(2);      // set = [1, 2]
> myHashSet.contains(2); // 返回 True
> myHashSet.remove(2);   // set = [1]
> myHashSet.contains(2); // 返回 False ，（已移除）



##### [题解](https://leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/)

* 哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上
* 冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：
  * 链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。
  * 开放地址法：当发现哈希值 h 处产生冲突时，根据某种策略，从 h 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查h+1,h+2,h+3,… 这些整数对应的位置。
  * 再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。

* 扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。

######  链地址法
设哈希表的大小为 base，则可以设计一个简单的哈希函数：hash(x) = x mod hash(x)=x mod base。

我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。

由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将base 取为一个质数。在这里，我们取 base=769。

```js
/**
 * Initialize your data structure here.
 */
var MyHashSet = function() {
	this.BASE = 769;
    this.data = new Array(this.BASE).fill(0).map(()=>new Array());
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.add = function(key) {
    const h = this.hash(key);
    // for(const item of  this.data[h]){
    //     if(item === key){
    //         return;
    //     }
    // }
    if(this.data[h].indexOf(key)>-1){
        return;
    }
    this.data[h].push(key);
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.remove = function(key) {
    const h = this.hash(key);
    const it = this.data[h];
    for(let i = 0;i<it.length;++i){
        if(it[i]===key){
            it.splice(i,1);
        	return;
        }
    }
};

/**
 * Returns true if this set contains the specified element 
 * @param {number} key
 * @return {boolean}
 */
MyHashSet.prototype.contains = function(key) {
    const h = this.hash(key);
    // for(const item of this.data[h]){
    //     if(item === key){
    //         return  true;
    //     }
    // }
    if(this.data[h].indexOf(key)>-1){
        return true;
    }
    return false;
};

MyHashSet.prototype.hash = function(key) {
	return key%this.BASE;
};
/**
 * Your MyHashSet object will be instantiated and called as such:
 * var obj = new MyHashSet()
 * obj.add(key)
 * obj.remove(key)
 * var param_3 = obj.contains(key)
 */
```



##### 复杂度分析

* 时间复杂度：`O(n/b)`。其中 `n` 为哈希表中的元素数量，`b `为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为` n/b`

* 空间复杂度：`O(n+b)`。



##### 参考链接

1.https://leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/



#### [1603. 设计停车系统](https://leetcode-cn.com/problems/design-parking-system/)

请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。

请你实现 `ParkingSystem` 类：

`ParkingSystem(int big, int medium, int small)` 初始化 `ParkingSystem` 类，三个参数分别对应每种停车位的数目。
`bool addCar(int carType)` 检查是否有 `carType` 对应的停车位。 `carType` 有三种类型：大，中，小，分别用数字 `1`， `2` 和 `3` 表示。一辆车只能停在  `carType` 对应尺寸的停车位中。如果没有空车位，请返回 `false` ，否则将该车停入车位并返回`true` 。

**示例 1：**

```
输入：
["ParkingSystem", "addCar", "addCar", "addCar", "addCar"]
[[1, 1, 0], [1], [2], [3], [1]]
输出：
[null, true, true, false, false]

解释：
ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);
parkingSystem.addCar(1); // 返回 true ，因为有 1 个空的大车位
parkingSystem.addCar(2); // 返回 true ，因为有 1 个空的中车位
parkingSystem.addCar(3); // 返回 false ，因为没有空的小车位
parkingSystem.addCar(1); // 返回 false ，因为没有空的大车位，唯一一个大车位已经被占据了
```

**提示：**

```
0 <= big, medium, small <= 1000
carType 取值为 1， 2 或 3
最多会调用 addCar 函数 1000 次
```

##### 题解

按照题目要求构建一个map,在读取的过程中，判断三个map的值，是否小于0，如果小于0则返回false

```js
/**
 * @param {number} big
 * @param {number} medium
 * @param {number} small
 */
var ParkingSystem = function(big, medium, small) {
    this.garage = new Map();
    this.garage.set('1',big);
    this.garage.set('2',medium);
    this.garage.set('3',small);
};

/** 
 * @param {number} carType
 * @return {boolean}
 */
ParkingSystem.prototype.addCar = function(carType) {
    switch(''+carType){
        case '1':
            var num = this.garage.get('1');
            if(num>=1){
                num--;
                this.garage.set('1',num);
                return true;
            }else{
                return false;
            }
            break;
        case '2':
            var num = this.garage.get('2');
            if(num>=1){
                num--;
                this.garage.set('2',num);
                return true;
            }else{
                return false;
            }
            break;
        case '3':
            var num = this.garage.get('3');
            if(num>=1){
                num--;
                this.garage.set('3',num);
                return true;
            }else{
                return false;
            }
            break;
    }
};

/**
 * Your ParkingSystem object will be instantiated and called as such:
 * var obj = new ParkingSystem(big, medium, small)
 * var param_1 = obj.addCar(carType)
 */
```



##### 复杂度分析

时间和空间复杂度O(1)



##### 参考链接

1. https://leetcode-cn.com/problems/design-parking-system



#### [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

**提示：**

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。

在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

>
> 示例 1：
>
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> 示例 2：
>
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
> 示例 3：
>
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

**提示：**

输入必须是长度为 32 的 二进制串 。

**进阶：**

如果多次调用这个函数，你将如何优化你的算法？



##### 题解

补码：

- 正数：正整数的补码是其二进制表示，与[原码](https://baike.baidu.com/item/原码)相同

  +9的补码是00001001。（备注：这个+9的补码是用8位2[进制](https://baike.baidu.com/item/进制)来表示的，补码表示方式很多，还有16位二进制补码表示形式，以及32位二进制补码表示形式，64位进制补码表示形式等。每一种补码表示形式都只能表示有限的数字。）

- 负数：求负整数的补码，将其原码除符号位外的所有位取反（0变1，1变0，符号位为1不变）后加1

  -5对应带符号位负数5（10000101）→除符号位外所有位取反（11111010）→加00000001(11111011)

  所以-5的补码是11111011。

- 0：数0的补码表示是**唯一**的 。

  [+0]补=[+0]反=[+0]原=00000000

  [ -0]补=11111111+1=00000000

##### 解法一：循环检查二进制位

我们可以直接循环检查给定整数 `n` 的二进制位的每一位是否为` 1`。

具体代码中，当检查第 `i `位时，我们可以让` n` 与 `2^i`进行与运算，当且仅当 `n` 的第 `i` 位为 `1` 时，运算结果不为 `0`。


```js
var hamingWeight = function(n){
    let res = 0;
    for(let i=0;i<32;i++){
        if((n&(1<<i))!==0){
            res++;
        }
    }
    retrun res;
}
```

##### 解法二：位运算优化

观察这个运算：`n&(n - 1)`，其运算结果恰为把` n `的二进制位中的最低位的 `1` 变为` 0` 之后的结果。

如：`6&(6-1) = 4, 6 = (110)_2, 4 = (100)_2`，运算结果` 4` 即为把 `6 `的二进制位中的最低位的` 1 `变为 `0` 之后的结果。

这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的 `n` 与 `n - 1 `做与运算，直到 `n` 变为 `0 `即可。因为每次运算会使得 `n` 的最低位的`1` 被翻转，因此运算次数就等于 `n `的二进制位中 `1 `的个数。

```js
var hamingWeight = function(){
    let res = 0;
    while(n){
        n&=n-1;
        res++;
    }
    return res;
}
```

##### 解法三 bitCount源码

```java
public class Solution{
    public int hamingWeight(int n){
        n = n-((n>>>1)&0x55555555);
        n = (n&0x33333333)+((n>>>2)&0x3333333);
        n = n+(n>>>4)&0x0f0f0f0f;
        n = n+(n>>>8);
        n = n+(n>>>16);
        return n&0x3f;
    }
}
```



##### 参考链接

[1.补码](https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613?fromtitle=%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81&fromid=5295284)

[2.位1的个数Leetcode](https://leetcode-cn.com/problems/number-of-1-bits/solution/wei-1de-ge-shu-by-leetcode-solution-jnwf/)

[3.《数据结构（C++）》](https://blog.csdn.net/weixin_30587927/article/details/101093369)

