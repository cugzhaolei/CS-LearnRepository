### 2021-3

#### [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

**难度**`中等`

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

 

> 示例 1：
>
> 输入：s = "3+2*2"
> 输出：7
> 示例 2：
>
> 输入：s = " 3/2 "
> 输出：1
> 示例 3：
>
> 输入：s = " 3+5 / 2 "
> 输出：5


提示：

- 1 <= s.length <= 3 * 105
- s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
- s 表示一个 有效表达式
- 表达式中的所有整数都是非负整数，且在范围 [0, 231 - 1] 内
- 题目数据保证答案是一个 32-bit 整数

##### [题解](https://leetcode-cn.com/problems/basic-calculator-ii/solution/ji-ben-ji-suan-qi-ii-by-leetcode-solutio-cm28/)

方法一：栈
思路

由于乘除优先于加减计算，因此不妨考虑先进行所有乘除运算，并将这些乘除运算后的整数值放回原表达式的相应位置，则随后整个表达式的值，就等于一系列整数加减后的值。

基于此，我们可以用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。

具体来说，遍历字符串 `s`，并用变量`preSign` 记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号。每次遍历到数字末尾时，根据 `preSign` 来决定计算方式：

* 加号：将数字压入栈；
* 减号：将数字的相反数压入栈；
* 乘除号：计算数字与栈顶元素，并将栈顶元素替换为计算结果。
  代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。处理完该数字后，更新 `preSign` 为当前遍历的字符。

遍历完字符串 ss 后，将栈中元素累加，即为该字符串表达式的值

```js
var calculate = function(s) {
    s = s.trim();
    const stack = new Array();
    let preSign = '+';
    let num = 0;
    const n = s.length;
    for (let i = 0; i < n; ++i) {
        if (!isNaN(Number(s[i])) && s[i] !== ' ') { // 是数字或者是空格时
            num = num * 10 + s[i].charCodeAt() - '0'.charCodeAt(); // 全局num 1 12 123
        }
        if (isNaN(Number(s[i])) || i === n - 1) { //特殊符号 或者是最后一个
            switch (preSign) {
                case '+':
                    stack.push(num);
                    break;
                case '-':
                    stack.push(-num);
                    break;
                case '*':
                    stack.push(stack.pop() * num);
                    break;
                default:
                    stack.push(stack.pop() / num | 0);
            }   
            preSign = s[i];
            num = 0;
        }
    }
    let ans = 0;
    while (stack.length) {
        ans += stack.pop();
    }
    return ans;
};
```

##### 复杂度分析

时间复杂度：`O(n)`，其中 `n` 为字符串 `s`的长度。需要遍历字符串 `s` 一次，计算表达式的值。

空间复杂度：`O(n)`，其中 `n`为字符串 `s` 的长度。空间复杂度主要取决于栈的空间，栈的元素个数不超过 `n`。

 ##### 参考链接

https://leetcode-cn.com/problems/basic-calculator-ii/

https://leetcode-cn.com/problems/basic-calculator-ii/solution/shi-yong-shuang-zhan-jie-jue-jiu-ji-biao-c65k/



#### [331. 验证二叉树的前序序列化](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/)

**难度** `中等` `栈`



序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 #。

```bash
       _9_
      /   \
     3     2
   / \    / \
  4   1  #  6
 / \  / \   / \
# # # #  #  #
```


例如，上面的二叉树可以被序列化为字符串` "9,3,4,#,#,1,#,#,2,#,6,#,#"`，其中 # 代表一个空节点。

给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。

每个以逗号分隔的字符或为一个整数或为一个表示 `null` 指针的 `'#'` 。

你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如` "1,,3"` 。

> 示例 1:
>
> 输入: "9,3,4,#,#,1,#,#,2,#,6,#,#"
> 输出: true`
> 示例 2:
>
> 输入: "1,#"
> 输出: false
> 示例 3:
>
> 输入: "9,#,#,1"
> 输出: false



##### [题解一](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/)

我们可以定义一个概念，叫做槽位。一个槽位可以被看作「当前二叉树中正在等待被节点填充」的那些位置。

二叉树的建立也伴随着槽位数量的变化。每当遇到一个节点时：

* 如果遇到了空节点，则要消耗一个槽位；

* 如果遇到了非空节点，则除了消耗一个槽位外，还要再补充两个槽位。

此外，还需要将根节点作为特殊情况处理。

![fig1](https://i.loli.net/2021/03/13/PivywLpIotOg6MH.png)

我们使用栈来维护槽位的变化。栈中的每个元素，代表了对应节点处剩余槽位的数量，而栈顶元素就对应着下一步可用的槽位数量。当遇到空节点时，仅将栈顶元素减 1；当遇到非空节点时，**将栈顶元素减** 1 后，再向栈中压入一个 2。无论何时，如果栈顶元素变为 0，就立刻将栈顶弹出。

遍历结束后，若栈为空，说明没有待填充的槽位，因此是一个合法序列；否则若栈不为空，则序列不合法。此外，在遍历的过程中，若槽位数量不足，则序列不合法。

```js
/**
 * @param {string} preorder
 * @return {boolean}
 */
var isValidSerialization = function(preorder) {
    const n = preorder.length;
    let i = 0;
    const stack = [1];
    while (i < n) {
        if (!stack.length) {
            return false;
        }
        if (preorder[i] === ',') {
            ++i;
        } else if (preorder[i] === '#') {
            stack[stack.length - 1]--;
            if (stack[stack.length - 1] === 0) {
                stack.pop();
            } 
            ++i;
        } else {
            // 读一个数字
            while (i < n && preorder[i] !== ',') {
                ++i;
            }
            stack[stack.length - 1]--;
            if (stack[stack.length - 1] === 0) {
                stack.pop();
            }
            stack.push(2);
        }
    }
    return stack.length === 0;
};

// 将栈顶的操作每次都在取数的时候操作

```



##### 复杂度分析

时间复杂度：`O(n)`，其中 `n` 为字符串的长度。我们每个字符只遍历一次，同时每个字符对应的操作都是常数时间的。

空间复杂度：`O(n)`。此为栈所需要使用的空间

##### [解法二](https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/pai-an-jiao-jue-de-liang-chong-jie-fa-zh-66nt/)

X # #的数据合成

如输入：` "9,3,4,#,#,1,#,#,2,#,6,#,#" `，当遇到 `x,#,#` 的时候，就把它变为` #`。

模拟一遍过程：

> [9,3,4,#,#] => [9,3,#]，继续
> [9,3,#,1,#,#] => [9,3,#,#] => [9,#] ，继续
> [9,#2,#,6,#,#] => [9,#,2,#,#] => [9,#,#] => [#]，结束



```js
/**
 * @param {string} preorder
 * @return {boolean}
 */
var isValidSerialization = function(preorder) {
    let stack= [];
    for(let s of preorder.split(',')){
        stack.unshift(s);
        while(stack.length>=3&&stack[0] == '#'&&stack[1] == '#'&&stack[2] != '#'){
            stack.shift();
            stack.shift();
            stack.shift();
            stack.unshift('#');
        }
    }
    return stack.length == 1&&stack.shift() == '#';
};
```

- 时间复杂度：`O(N)`
- 空间复杂度：`O(N)`

###### 计算入度出度

背景知识：

* 入度：有多少个节点指向它；
* 出度：它指向多少个节点。
  我们知道在树（甚至图）中，所有节点的入度之和等于出度之和。可以根据这个特点判断输入序列是否为有效的！

在一棵二叉树中：

* 每个空节点（ "#" ）会提供 0 个出度和 1 个入度。
* ..每个非空节点会提供 2 个出度和 1 个入度（根节点的入度是 0）。

我们只要把字符串遍历一次，每个节点都累加 `diff = 出度 - 入度` 。在遍历到任何一个节点的时候，要求`diff >= 0`，原因是还没遍历到该节点的子节点，所以此时的出度应该大于等于入度。当所有节点遍历完成之后，整棵树的` diff == 0` 。

这里解释一下为什么下面的代码中 diff 的初始化为 1。因为，我们加入一个非空节点时，都会对 diff 先减去 1（入度），再加上 2（出度）。但是由于根节点没有父节点，所以其入度为 0，出度为 2。因此 diff 初始化为 1，是为了在加入根节点的时候，diff 先减去 1（入度），再加上 2（出度），此时 diff 正好应该是2.



```js
var isValidSerialization = function(preorder) {
    const nodes = preorder.split(',');
    let diff = 1;
    for(const node of nodes){
        diff -=1;
        if(diff<0){
            return false;
        }
        if(node!='#'){
            diff +=2;
        }
    }
    return diff == 0;
}
```

- 时间复杂度：`O(N)`
- 空间复杂度：`O(1)`

##### 参考链接

1. https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/

   

#### [705. 设计哈希集合](https://leetcode-cn.com/problems/design-hashset/)

不使用任何内建的哈希表库设计一个哈希集合（HashSet）。

实现 MyHashSet 类：

* void add(key) 向哈希集合中插入值 key 。
* bool contains(key) 返回哈希集合中是否存在这个值 key 。
* void remove(key) 将给定值 key 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。

示例：

> 输入：
> ["MyHashSet", "add", "add", "contains", "contains", "add", "contains", "remove", "contains"]
> [[], [1], [2], [1], [3], [2], [2], [2], [2]]
> 输出：
> [null, null, null, true, false, null, true, null, false]
>
> 解释：
> MyHashSet myHashSet = new MyHashSet();
> myHashSet.add(1);      // set = [1]
> myHashSet.add(2);      // set = [1, 2]
> myHashSet.contains(1); // 返回 True
> myHashSet.contains(3); // 返回 False ，（未找到）
> myHashSet.add(2);      // set = [1, 2]
> myHashSet.contains(2); // 返回 True
> myHashSet.remove(2);   // set = [1]
> myHashSet.contains(2); // 返回 False ，（已移除）



##### [题解](https://leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/)

* 哈希函数：能够将集合中任意可能的元素映射到一个固定范围的整数值，并将该元素存储到整数值对应的地址上
* 冲突处理：由于不同元素可能映射到相同的整数值，因此需要在整数值出现「冲突」时，需要进行冲突处理。总的来说，有以下几种策略解决冲突：
  * 链地址法：为每个哈希值维护一个链表，并将具有相同哈希值的元素都放入这一链表当中。
  * 开放地址法：当发现哈希值 h 处产生冲突时，根据某种策略，从 h 出发找到下一个不冲突的位置。例如，一种最简单的策略是，不断地检查h+1,h+2,h+3,… 这些整数对应的位置。
  * 再哈希法：当发现哈希冲突后，使用另一个哈希函数产生一个新的地址。

* 扩容：当哈希表元素过多时，冲突的概率将越来越大，而在哈希表中查询一个元素的效率也会越来越低。因此，需要开辟一块更大的空间，来缓解哈希表中发生的冲突。

######  链地址法
设哈希表的大小为 base，则可以设计一个简单的哈希函数：hash(x) = x mod hash(x)=x mod base。

我们开辟一个大小为 base 的数组，数组的每个位置是一个链表。当计算出哈希值之后，就插入到对应位置的链表当中。

由于我们使用整数除法作为哈希函数，为了尽可能避免冲突，应当将base 取为一个质数。在这里，我们取 base=769。

```js
/**
 * Initialize your data structure here.
 */
var MyHashSet = function() {
	this.BASE = 769;
    this.data = new Array(this.BASE).fill(0).map(()=>new Array());
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.add = function(key) {
    const h = this.hash(key);
    // for(const item of  this.data[h]){
    //     if(item === key){
    //         return;
    //     }
    // }
    if(this.data[h].indexOf(key)>-1){
        return;
    }
    this.data[h].push(key);
};

/** 
 * @param {number} key
 * @return {void}
 */
MyHashSet.prototype.remove = function(key) {
    const h = this.hash(key);
    const it = this.data[h];
    for(let i = 0;i<it.length;++i){
        if(it[i]===key){
            it.splice(i,1);
        	return;
        }
    }
};

/**
 * Returns true if this set contains the specified element 
 * @param {number} key
 * @return {boolean}
 */
MyHashSet.prototype.contains = function(key) {
    const h = this.hash(key);
    // for(const item of this.data[h]){
    //     if(item === key){
    //         return  true;
    //     }
    // }
    if(this.data[h].indexOf(key)>-1){
        return true;
    }
    return false;
};

MyHashSet.prototype.hash = function(key) {
	return key%this.BASE;
};
/**
 * Your MyHashSet object will be instantiated and called as such:
 * var obj = new MyHashSet()
 * obj.add(key)
 * obj.remove(key)
 * var param_3 = obj.contains(key)
 */
```



##### 复杂度分析

* 时间复杂度：`O(n/b)`。其中 `n` 为哈希表中的元素数量，`b `为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为` n/b`

* 空间复杂度：`O(n+b)`。



##### 参考链接

1.https://leetcode-cn.com/problems/design-hashset/solution/she-ji-ha-xi-ji-he-by-leetcode-solution-xp4t/



#### [706. 设计哈希映射](https://leetcode-cn.com/problems/design-hashmap/)

**难度**`简单`



不使用任何内建的哈希表库设计一个哈希映射（`HashMap`）。

实现 `MyHashMap` 类：

- `MyHashMap()` 用空映射初始化对象
- `void put(let key, let value)` 向 `HashMap` 插入一个键值对 `(key, value)` 。如果 `key `已经存在于映射中，则更新其对应的值 value 。
- `let get(let key)` 返回特定的 `key` 所映射的` value` ；如果映射中不包含` key` 的映射，返回` -1 `。
- `void remove(key) `如果映射中存在` key `的映射，则移除 `key `和它所对应的` value` 。

示例：

```

输入：
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
输出：
[null, null, null, 1, -1, null, 1, null, -1]

解释：
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]
myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]
myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]
myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）
myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]
myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]
myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]

```


提示：

- 0 <= key, value <= 106

- 最多调用 104 次 put、get 和 remove 方法



##### 题解

###### 拉链法

```js
/**
 * Initialize your data structure here.
 */
var MyHashMap = function() {
	this.BASE = 769;
        this.data = new Array(this.BASE).fill(0).map(()=>new Array());
};

/**
 * value will always be non-negative. 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
MyHashMap.prototype.put = function(key, value) {
	const position = this.getHash(key);
        for(const it of this.data[position]){
            if(it[0]=== key){
		it[1]=value;
                return;
            }
        }
        this.data[position].push([key,value]);
};

/**
 * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key 
 * @param {number} key
 * @return {number}
 */
MyHashMap.prototype.get = function(key) {
	const position = this.getHash(key);
        for(const it of this.data[position]){
            if(it[0]===key){
                return it[1];
            }
        }
        return -1;
};

/**
 * Removes the mapping of the specified value key if this map contains a mapping for the key 
 * @param {number} key
 * @return {void}
 */
MyHashMap.prototype.remove = function(key) {
	const position = this.getHash(key);
        for(const it of this.data[position]){
            if(it[0]===key){
                const index = this.data[position].indexOf(it);
                this.data[position].splice(index,1);
                return;
            }
        }
};

/**
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */
MyHashMap.prototype.getHash = function(key){
    return key%this.BASE;
}
```

##### 复杂度分析

- 时间复杂度：`O( b/n)`。其中 `n` 为哈希表中的元素数量，`b` 为链表的数量。假设哈希值是均匀分布的，则每个链表大概长度为 `b/n`。

- 空间复杂度：`O(n+b)`。

###### 超大数组

```js
/**
 * Initialize your data structure here.
 */
var MyHashMap = function() {
    this.data = new Array(1000001).fill(0);
};

/**
 * value will always be non-negative. 
 * @param {number} key 
 * @param {number} value
 * @return {void}
 */
MyHashMap.prototype.put = function(key, value) {
	const position = this.getHash(key);
    	this.data[position] = value;
};

/**
 * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key 
 * @param {number} key
 * @return {number}
 */
MyHashMap.prototype.get = function(key) {
	const position = this.getHash(key);
        if(this.data[position]){
            return this.data[position];
        }else{
            return -1;
        }
};

/**
 * Removes the mapping of the specified value key if this map contains a mapping for the key 
 * @param {number} key
 * @return {void}
 */
MyHashMap.prototype.remove = function(key) {
	const position = this.getHash(key);
        if(this.data[position]){
             const index = this.data.indexOf(this.data[position]);
             this.data.splice(index,1);
             return;
        }
};

/**
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */
MyHashMap.prototype.getHash = function(key){
    let hash = 0;
    for(let i=0;i<key.length;i++){
	hash += key.charCodeAt(i);	
    }
    return hash%1000001; // 题目中不大于10的6次方
}
```

##### 复杂度分析

- 时间复杂度：`O( 1)`。

- 空间复杂度：`O(n)`。

##### 参考链接

1.https://leetcode-cn.com/problems/design-hashmap/submissions/

2.https://leetcode-cn.com/problems/design-hashmap/solution/xiang-jie-hashmap-de-she-ji-zai-shi-jian-85k9/



#### [54. 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：

![img](https://i.loli.net/2021/03/15/kTqDQpWal5V6js8.jpg)

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```
示例 2：

![img](https://i.loli.net/2021/03/15/kTqDQpWal5V6js8.jpg)

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

提示：

```

* m == matrix.length
* n == matrix[i].length
* 1 <= m, n <= 10
* -100 <= matrix[i][j] <= 100

```



##### 题解1 模拟

可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。

判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵`visited`，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 `visited `中的对应位置的元素设为已访问。

如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。

```js
var spiralOrder = function(matrix){
    if(!matrix.length||!matrix[0].length){
        return [];
    }
    const rows = matrix.length,columns = matrix[0].length;
    const visited = new Array(rows).fill(0).map(()=>new Array(columns).fill(false));
    const total = rows*columns;
    const order = new Array(total).fill(0);
    
    let directionIndex = 0,row = 0,column = 0;
    const direction = [[0,1],[1,0],[0,-1],[-1,0]];
    
    for(let i=0;i<total;i++){
        order[i] = matrix[row][column];
        visited[row][column] = true;
        const nextRow = row + directions[directionIndex][0],nextColumn = column + directions[directionIndex][1];
        if(!(0<nextRow&&nextRow<rows&&0<=nextColumn&&nextColumn<columns&&!(visited[nextRow][nextColumn]))){
            directionIndex = (directionIndex+1)%4;
        }
        row += directions[directionIndex][0];
        column += directions[directionIndex][1];
    } 
    return order;
}
```



##### 复杂度分析

时间复杂度：`O(mn)`，其中` m` 和 `n `分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。

空间复杂度：`O(mn)`。需要创建一个大小为 m×n 的矩阵` visited` 记录每个位置是否被访问过。



##### 题解2 按层模拟

可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。

定义矩阵的第 `k `层是到最近边界距离为 `k` 的所有顶点。例如，下面矩阵最外层元素都是第` 1 `层，次外层元素都是第 `2 `层，剩下的元素都是第` 3` 层。

> [[1, 1, 1, 1, 1, 1, 1],
>  [1, 2, 2, 2, 2, 2, 1],
>  [1, 2, 3, 3, 3, 2, 1],
>  [1, 2, 2, 2, 2, 2, 1],
>  [1, 1, 1, 1, 1, 1, 1]]

对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于` (top,left)`，右下角位于`(bottom,right)`，按照如下顺序遍历当前层的元素。

1. 从左到右遍历上侧元素，依次为`(top,left)` 到` (top,right)`。
2. 从上到下遍历右侧元素，依次为` (top+1,right) `到 `(bottom,right)`。
3. 如果`left<right `且`top<bottom`，则从右到左遍历下侧元素，依次为` (bottom,right−1)` 到`(bottom,left+1)`，以及从下到上遍历左侧元素，依次为`(bottom,left)` 到`(top+1,left)`。

遍历完当前层的元素之后，将`left `和` top `分别增加 1，将 `right `和` bottom `分别减少`1`，进入下一层继续遍历，直到遍历完所有元素为止。

![fig1](https://i.loli.net/2021/03/15/aXOi4FHnDLIMSv5.png)



```js
var spiralOrder = function(matrix) {
    if (!matrix.length || !matrix[0].length) {
        return [];
    }

    const rows = matrix.length, columns = matrix[0].length;
    const order = [];
    let left = 0, right = columns - 1, top = 0, bottom = rows - 1;
    while (left <= right && top <= bottom) {
        for (let column = left; column <= right; column++) {
            order.push(matrix[top][column]);
        }
        for (let row = top + 1; row <= bottom; row++) {
            order.push(matrix[row][right]);
        }
        if (left < right && top < bottom) {
            for (let column = right - 1; column > left; column--) {
                order.push(matrix[bottom][column]);
            }
            for (let row = bottom; row > top; row--) {
                order.push(matrix[row][left]);
            }
        }
        [left, right, top, bottom] = [left + 1, right - 1, top + 1, bottom - 1];
    }
    return order;
};


var spiralOrder = function(matrix) {
    let ans = [];
        if(matrix.length<=0||matrix[0].length<=0) return ans; //若数组为空，直接返回答案
        let u = 0; //赋值上下左右边界
        let d = matrix.length() - 1;
        let l = 0;
        let r = matrix[0].length() - 1;
        while(true)
        {
            for(let i = l; i <= r; ++i) ans.push(matrix[u][i]); //向右移动直到最右
            if(++ u > d) break; //重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同
            for(let i = u; i <= d; ++i) ans.push(matrix[i][r]); //向下
            if(-- r < l) break; //重新设定有边界
            for(let i = r; i >= l; --i) ans.push(matrix[d][i]); //向左
            if(-- d < u) break; //重新设定下边界
            for(let i = d; i >= u; --i) ans.push(matrix[i][l]); //向上
            if(++ l > r) break; //重新设定左边界
        }
        return ans;
}

```

##### 复杂度分析

* 时间复杂度：`O(mn)`，其中 `m`和 `n`分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。
* 空间复杂度：`O(1)`。除了输出数组以外，空间复杂度是常数。



##### 参考链接

1. https://leetcode-cn.com/problems/spiral-matrix/
2. https://leetcode-cn.com/problems/spiral-matrix/solution/luo-xuan-ju-zhen-by-leetcode-solution/
3. https://leetcode-cn.com/problems/spiral-matrix/solution/cxiang-xi-ti-jie-by-youlookdeliciousc-3/



#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

**难度**：`困难`



给定一个字符串 `s` 和一个字符串 `t` ，计算在` s` 的子序列中 `t `出现的个数。

字符串的一个 `子序列` 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，`"ACE"` 是`"ABCDE"` 的一个子序列，而` "AEC" `不是）

题目数据保证答案符合 32 位带符号整数范围。

 

**示例 1：**

> 输入：s = "rabbbit", t = "rabbit"
> 输出：3
> 解释：
> 如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
> (上箭头符号 ^ 表示选取的字母)
> rabbbit
> ^^^^ ^^
> rabbbit
> ^^ ^^^^
> rabbbit
> ^^^ ^^^



**示例 2：**

> 输入：s = "babgbag", t = "bag"
> 输出：5
> 解释：
> 如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
> (上箭头符号 ^ 表示选取的字母)
> babgbag
> ^^ ^
> babgbag
> ^^    ^
> babgbag
> ^    ^^
> babgbag
>   ^  ^^
> babgbag
>     ^^^



**提示：**

- `0 <= s.length, t.length <= 1000`

- s 和 t 由英文字母组成



##### 题解

###### 动态规划1

`dp[i][j] `代表 `T `前 `i `字符串可以由` S j `字符串组成最多个数.

所以动态方程:

当 `S[j] == T[i] , dp[i][j] = dp[i-1][j-1] + dp[i][j-1];`

当 `S[j] != T[i] , dp[i][j] = dp[i][j-1]`

举个例子,如示例的

![1561970400084.png](https://i.loli.net/2021/03/17/EHdoNYK7qUyxa8h.png)

对于第一行, T 为空,因为空集是所有字符串子集, 所以我们第一行都是 1

对于第一列, S 为空,这样组成 T 个数当然为 0` 了



```js
/**
 * @param {string} s
 * @param {string} t
 * @return {number}
 */
var numDistinct = function(s, t) {
	const dp = new Array(t.length()+1).map(()=>new Array(t.length()+1));
    for(let j=0;j<s.length()+1;j++) dp[0][j] = 1;
    for(let i=1;i<t.length()+1;i++){
        for(let j = 1;j<s.length()+1;j++){
            if(t.charAt(i-1)==s.charAt(j-1)){
                dp[i][j] = dp[i-1][j-1] + dp[i][j-1];
            }else{
                dp[i][j] = dp[i][j-1]
            }
        }
        return dp[t.length][s.length()];
    }
};
```

```js
var numDistinct = function(s, t) {
    const m = s.length, n = t.length;
    if (m < n) {
        return 0;
    }
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));
    for (let i = 0; i <= m; i++) {
        dp[i][n] = 1;
    }
    for (let i = m - 1; i >= 0; i--) {
        for (let j = n - 1; j >= 0; j--) {
            if (s[i] == t[j]) {
                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
            } else {
                dp[i][j] = dp[i + 1][j];
            }
        }
    }
    return dp[0][0];
};

```



##### 复杂度分析

- 时间复杂度：`O(mn)`，其中 `m` 和 `n` 分别是字符串 `s` 和` t` 的长度。二维数组dp 有 `m+1`行和 `n+1 `列，需要对 `dp` 中的每个元素进行计算。

- 空间复杂度：`O(mn)`，其中 `m `和 `n `分别是字符串` s `和` t `的长度。创建了` m+1` 行`n+1` 列的二维数组 `dp`。



##### 参考链接



1.https://leetcode-cn.com/problems/distinct-subsequences/solution/dong-tai-gui-hua-by-powcai-5/

2.https://leetcode-cn.com/problems/distinct-subsequences/solution/bu-tong-de-zi-xu-lie-by-leetcode-solutio-urw3/