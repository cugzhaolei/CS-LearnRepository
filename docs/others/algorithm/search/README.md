# 搜索算法

## BFS

广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。

![bfs](algorithm-LeetCode-search-bfs.jpg)

第一层：

- 0 -> {6,2,1,5}
  第二层：

- 6 -> {4}
- 2 -> {}
- 1 -> {}
- 5 -> {3}
  第三层：

- 4 -> {}
- 3 -> {}

每一层遍历的节点都与根节点距离相同。设 d~i~ 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 d~i~ <= d~j~。利用这个结论，可以求解最短路径等 最优解 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。

## DFS

## KMP

```js
```

#### LRU缓存算法

**LRU（Least Recently Used）**是一种常见的页面置换算法，在计算中，所有的文件操作都要放在内存中进行，然而计算机内存大小是固定的，所以我们不可能把所有的文件都加载到内存，因此我们需要制定一种策略对加入到内存中的文件进项选择。

常见的页面置换算法有如下几种：

- LRU 最近最久未使用

- FIFO 先进先出置换算法 类似队列

- OPT 最佳置换算法 （理想中存在的）

- NRU Clock置换算法

- LFU 最少使用置换算法

- PBA 页面缓冲算法

  

  ##### LRU原理

  LRU的设计原理就是，当数据在最近一段时间经常被访问，那么它在以后也会经常被访问。这就意味着，如果经常访问的数据，我们需要然其能够快速命中，而不常访问的数据，我们在容量超出限制内，要将其淘汰。



[1.LRU算法缓存算法实现](https://blog.csdn.net/qq_26440803/article/details/83795122)

[2.LRU算法](https://www.jianshu.com/p/d533d8a66795)

